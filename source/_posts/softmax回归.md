---
title: softmax回归
categories: PyTorch
date: 2023-09-16 16:05:00
mathjax: true
---

## Softmax回归

Softmax回归，也被称为多类别逻辑回归，是一种常用的分类算法。和线性回归不同，softmax回归的输出单元从一个变成了多个，且引入了softmax运算使输出更适合离散值的预测和训练。它可以用于将输入数据分为多个类别，每个类别的概率由Softmax函数计算得出。

在Softmax回归中，假设有n个类别，每个类别都有一个对应的权重向量和偏置项。给定输入样本x，Softmax回归首先计算每个类别的得分，即将输入样本与每个类别的权重向量进行点积，并加上对应的偏置项。然后，通过Softmax函数将这些得分转化为概率分布，使得所有类别的概率之和为1。

Softmax函数的定义如下：
$$
\text{softmax}(z_i) = \frac{e^{z_i}}{\sum_{j=1}^{n} e^{z_j}}
$$

其中，$z_i$表示第i个类别的得分，$e$表示自然常数。

Softmax回归可以通过最大似然估计来进行参数的训练。通过最大化训练数据中正确类别的概率，可以得到最优的权重向量和偏置项。

Softmax回归在机器学习中广泛应用于多类别分类任务，例如图像分类、文本分类等。

## 分类问题

进行分类要选择如何表示标签。 我们有两个明显的选择：最直接的想法是选择$y∈{1,2,3}$， 其中整数分别代表狗猫鸡{狗,猫,鸡}。这是在计算机上存储此类信息的有效方法。 如果类别间有一些自然顺序，那么将这个问题转变为回归问题，并且保留这种格式是有意义的。

一般的分类问题并不与类别之间的自然顺序有关。 幸运的是，统计学家很早以前就发明了一种表示分类数据的简单方法：***独热编码*（one-hot encoding）**。 独热编码是一个向量，它的分量和类别一样多。 类别对应的分量设置为1，其他所有分量设置为0。 在我们的例子中，标签将是一个三维向量， 其中(1,0,0)对应于“猫”、(0,1,0)对应于“鸡”、(0,0,1)对应于“狗”：

## 网络架构

为了估计所有可能类别的条件概率，我们需要一个有多个输出的模型，每个类别对应一个输出。 为了解决线性模型的分类问题，我们需要和输出一样多的*仿射函数*（affine function）。 每个输出对应于它自己的仿射函数。 

我们的例子中，由于我们有4个特征和3个可能的输出类别， 我们将需要12个标量来表示权重（带下标的w）， 3个标量来表示偏置（带下标的b）。

我们可以用神经网络图来描述这个计算过程。 与线性回归一样，softmax回归也是一个单层神经网络。 由于计算每个输出$o_1$、$o_2$和$o_3$取决于 所有输入$x_1$、$x_2$、$x_3$和$x_4$， 所以softmax回归的输出层也是全连接层。

![../_images/softmaxreg.svg](https://zh-v2.d2l.ai/_images/softmaxreg.svg)



为了更简洁地表达模型，我们仍然使用线性代数符号。 通过向量形式表达为$o=Wx+b$， 这是一种更适合数学和编写代码的形式。 由此，我们已经将所有权重放到一个$3×4$矩阵中。 对于给定数据样本的特征$x$， 我们的输出是由权重与输入特征进行矩阵-向量乘法再加上偏置$b$得到的。

## 全连接层的参数开销

在深度学习中，全连接层无处不在。 然而，顾名思义，全连接层是“完全”连接的，可能有很多可学习的参数。

对于任何具有d个输入和q个输出的全连接层， 参数开销为$O(dq)$，这个数字在实践中可能高得令人望而却步。 成本可以减少到$O(\frac{dq}{n})$， 其中超参数n可以由我们灵活指定，以在实际应用中平衡参数节约和模型有效性 。

## Softmax运算

Softmax运算是一种常用于多分类问题的数学运算，它将一个向量的原始输出转换为一个概率分布。Softmax运算的输入是一个实数向量，输出是一个概率分布，其中每个元素的取值范围是0到1，且所有元素的和为1。（<u>不然将违反概率基本公理。</u>）Softmax运算通过对输入向量中的每个元素进行指数运算，然后将结果归一化得到输出向量。Softmax运算的公式如下：

$$
softmax(x_i) = \frac{exp(x_i)}{\sum exp(x_j)}
$$
其中，$x_i$表示输入向量中的第i个元素，exp表示指数函数，sum表示求和运算。

**原理**：*先对每个未规范化的预测求幂，这样可以确保输出非负。 为了确保最终输出的概率值总和为1，我们再让每个求幂后的结果除以它们的总和。*

softmax运算不会改变未规范化的预测x之间的大小次序，只会确定分配给每个类别的概率。

Softmax运算常用于神经网络中的输出层，用于将神经网络的原始输出转换为概率分布，从而进行多分类任务。在训练过程中，Softmax运算可以与交叉熵损失函数结合使用，来计算模型的损失并进行梯度下降更新。在预测过程中，Softmax运算可以根据输出向量中的概率值来确定最终的分类结果。

尽管softmax是一个非线性函数，但softmax回归的输出仍然由输入特征的仿射变换决定。 因此，softmax回归是一个*线性模型*（linear model）。

## 小批量样本的矢量化

小批量样本的矢量化是指将多个样本同时进行数据处理的一种方法。传统的样本处理方式是逐个处理每个样本，而小批量样本的矢量化则是将多个样本作为一个矩阵或张量进行处理，从而在计算上能够更高效地利用硬件资源。

在机器学习和深度学习中，通常会使用矩阵运算库（如NumPy）或深度学习框架（如TensorFlow、PyTorch）来实现小批量样本的矢量化。具体来说，将多个样本的特征表示按行组成一个矩阵，将多个样本的标签按行组成一个矩阵或向量，然后通过矩阵运算或张量运算来同时处理这个矩阵或张量。

小批量样本的矢量化能够提高计算效率，因为现代计算机的硬件通常能够高效地执行矩阵和张量运算。此外，矢量化还可以利用并行计算的优势，从而进一步加速计算过程。因此，在实际应用中，尽可能地将数据处理过程进行矢量化是一种常用的优化策略。

## 损失函数

需要一个损失函数来度量预测的效果。 我们将使用最大似然估计，这与在线性回归中的方法相同。

### 对数似然

对数似然（log-likelihood）是一种在统计学和机器学习中常用的评估模型拟合程度的指标。它是似然函数取对数后得到的值，通常用于最大似然估计（Maximum Likelihood Estimation，MLE）等参数估计方法中。

**似然函数是用于描述数据与模型参数之间关系的函数。对于给定的数据集，似然函数表示在给定参数下观察到该数据集的概率。通常情况下，我们希望找到使得似然函数取得最大值的参数值，这被称为最大似然估计。**

由于对数函数是单调递增的，因此取对数后的似然函数也具有相同的极值点，但在计算上更加方便。对数似然函数的优点是可以将概率乘积转换为对数概率之和，从而避免了计算机处理小数乘积时可能出现的数值下溢问题。

在机器学习中，对数似然函数常用于监督学习中的分类和回归问题，用于评估模型对观测数据的拟合程度。通过最大化对数似然函数，可以找到使得模型预测结果与真实标签最为一致的参数。

softmax函数给出了一个向量$\hat{\mathbf{y}}$，我们可以将其视为“对给定任意输入$x$的每个类的条件概率”。 例如，$\hat{y}_{1}=P(y=  猫  \mid \mathbf{x})$。假设整个数据集$\{\mathbf{X}, \mathbf{Y}\}$具有  n  个样本, 其中索引$i$的样本由特征向 量$\mathbf{x}^{(i)}$和独热标签向量$\mathbf{y}^{(i)}$组成。我们可以将估计值与实际值进行比较:

$$
P(\mathbf{Y} \mid \mathbf{X})=\prod_{i=1}^{n} P\left(\mathbf{y}^{(i)} \mid \mathbf{x}^{(i)}\right) \text {. }
$$
根据最大似然估计, 我们最大化$P(\mathbf{Y} \mid \mathbf{X})$，相当于最小化负对数似然:

$$
-\log P(\mathbf{Y} \mid \mathbf{X})=\sum_{i=1}^{n}-\log P\left(\mathbf{y}^{(i)} \mid \mathbf{x}^{(i)}\right)=\sum_{i=1}^{n} l\left(\mathbf{y}^{(i)}, \hat{\mathbf{y}}^{(i)}\right),
$$
其中，对于任何标签$\mathbf{y}$和模型预测$\hat{\mathbf{y}}$，损失函数为：

$$
l(\mathbf{y}, \hat{\mathbf{y}})=-\sum_{j=1}^{q} y_{j} \log \hat{y}_{j}
$$
损失函数 通常被称为 *交叉熵损失*（cross-entropy loss）。 由于y是一个长度为q的独热编码向量， 所以除了一个项以外的所有项j都消失了。 由于所有$\hat{\mathbf{y}}_j$都是预测的概率，所以它们的对数永远不会大于0。

### softmax及其导数

由于softmax和相关的损失函数很常见，因此我们需要更好地理解它的计算方式。将softmax函数代入损失函数中。利用softmax的定义, 我们得到:

$$
\begin{aligned}
l(\mathbf{y}, \hat{\mathbf{y}}) & =-\sum_{j=1}^{q} y_{j} \log \frac{\exp \left(o_{j}\right)}{\sum_{k=1}^{q} \exp \left(o_{k}\right)} \\
& =\sum_{j=1}^{q} y_{j} \log \sum_{k=1}^{q} \exp \left(o_{k}\right)-\sum_{j=1}^{q} y_{j} o_{j} \\
& =\log \sum_{k=1}^{q} \exp \left(o_{k}\right)-\sum_{j=1}^{q} y_{j} o_{j} .
\end{aligned}
$$
考虑相对于任何未规范化的预测$o_{j}$的**导数**，我们得到：*（下面一步是求导）*

$$
\partial_{o_{j}} l(\mathbf{y}, \hat{\mathbf{y}})=\frac{\exp \left(o_{j}\right)}{\sum_{k=1}^{q} \exp \left(o_{k}\right)}-y_{j}=\operatorname{softmax}(\mathbf{o})_{j}-y_{j}
$$
导数是我们softmax模型分配的概率与实际发生的情况（由独热标签向量表示）之间的差异。在任何指数族分布模型中， 对数似然的梯度正是由此得出的。 这使梯度计算在实践中变得容易很多。

### 交叉熵损失

交叉熵损失（Cross-Entropy Loss）是一种常用的损失函数，用于衡量模型输出与真实标签之间的差异。交叉熵损失通常用于分类问题，特别是多分类任务。

在分类问题中，模型的输出是一个概率分布向量，表示每个类别的概率。而真实标签是一个向量，其中只有一个元素为1，表示样本的真实类别。交叉熵损失通过比较模型输出的概率分布与真实标签的向量来度量模型预测的准确程度。

xxxxxxxxxx11 1import pickle2​3with open('./models/sentiment_classifier.pkl', 'wb') as f:4    pickle.dump(clf, f) #save5​6with open('./models/entiment_classifier.pkl', 'rb') as f:7    loaded_clf = pickle.load(f) #load8​9#apply10print(test_x[0])11loaded_clf.predict(test_x_vectors[0])python

$$
\mathrm{CE}(\mathrm{p}, \mathrm{q})=-\sum_{\mathrm{i}=1}^{\mathrm{C}} \mathrm{p}_{\mathrm{i}} \log \left(\mathrm{q}_{\mathrm{i}}\right)
$$
其中，log表示自然对数。

交叉熵损失的计算过程可以理解为将真实标签的概率分布向量与模型输出的概率分布向量进行比较，并取负对数来表示两个分布的差异。当模型的预测与真实标签完全一致时，交叉熵损失为0；当两者差异越大时，交叉熵损失越大。

在训练过程中，通常使用梯度下降等优化算法来最小化交叉熵损失，从而调整模型的参数，使得模型能够更好地拟合训练数据，并具有更好的泛化能力。

## 信息论基础

*信息论*（information theory）涉及编码、解码、发送以及尽可能简洁地处理信息或数据。

### 熵

信息论的核心思想是量化数据中的信息内容。 在信息论中，该数值被称为分布P的*熵*（entropy）。可以通过以下方程得到：
$$
H[P]=\sum_{j}-P(j) \log P(j)
$$
信息论的基本定理之一指出，为了对从分布p中随机抽取的数据进行编码， 我们至少需要�[�]“纳特（nat）”对其进行编码。 “纳特”相当于*比特*（bit），但是对数底为$e$而不是2。因此，一个纳特是$\frac{1}{log⁡(2)}≈1.44$比特。

### 信息量

压缩与预测有什么关系呢？ 想象一下，我们有一个要压缩的数据流。 如果我们很容易预测下一个数据，那么这个数据就很容易压缩。 为什么呢？ 举一个极端的例子，假如数据流中的每个数据完全相同，这会是一个非常无聊的数据流。 由于它们总是相同的，我们总是知道下一个数据是什么。 所以，为了传递数据流的内容，我们不必传输任何信息。也就是说，“下一个数据是xx”这个事件毫无信息量。

但是，如果我们不能完全预测每一个事件，那么我们有时可能会感到“惊异”。 克劳德·香农决定用信息量$log⁡\frac{1}{P(j)}=−log⁡ P(j)$来量化这种惊异程度。 在观察一个事件 j 时，并赋予它（主观）概率$P(j)$。 当我们赋予一个事件较低的概率时，我们的惊异会更大，该事件的信息量也就更大。 在前面定义的熵， 是当分配的概率真正匹配数据生成过程时的*信息量的期望*。

### 重新审视交叉熵

如果把熵$H(P)$想象为“知道真实概率的人所经历的惊异程度”，那么什么是交叉熵? 交叉熵从 P 到 Q，记为$H(P, Q)$。我们可以把交叉熵想象为“主观概率为 Q 的观察者在看到根据概率 P 生成 的数据时的预期惊异”。当 P=Q 时, 交叉熵达到最低。在这种情况下, 从 P 到 Q 的交叉熵是$H(P, P)=H(P)$。
简而言之, 我们可以从两方面来考虑交叉熵分类目标：

1. 最大化观测数据的似然；
2. 最小化传达标签所需的惊异。

## 模型预测和评估

在训练softmax回归模型后，给出任何样本特征，我们可以预测每个输出类别的概率。 通常我们使用预测概率最高的类别作为输出类别。 如果预测与实际类别（标签）一致，则预测是正确的。 在接下来的实验中，我们将使用*精度*（accuracy）来评估模型的性能。 精度等于正确预测数与预测总数之间的比率。
